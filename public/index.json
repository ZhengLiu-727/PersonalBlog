[{"categories":["LeetCode题解"],"content":"注意 👻 本人水平有限，如有建议，欢迎留言或邮件联系 👻 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have *exactly* one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? 思路 经典 two sum 解法 class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int[] res = new int[2]; for (int i = 0; i \u003c nums.length; i ++) { int complement = target - nums[i]; if (map.containsKey(complement)) { res[0] = i; res[1] = map.get(complement); break; } map.put(nums[i], i); } return res; } } ","date":"2021-12-25","objectID":"/leetcode_0001_twosum/:0:0","tags":["LeetCode","算法"],"title":"LeetCode 0001. TwoSum","uri":"/leetcode_0001_twosum/"},{"categories":["LeetCode题解"],"content":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: Input: candidates = [2], target = 1 Output: [] Constraints: 1 \u003c= candidates.length \u003c= 30 1 \u003c= candidates[i] \u003c= 200 All elements of candidates are distinct. 1 \u003c= target \u003c= 500 思路 典型的回溯法模版题， 用一个 list 记录当前的组合，用一个 int sum 记录组合中数字之和，index标记已经遍历到哪里，下一步可以选择从index到最后一个数中的任何一个 解法 class Solution { List\u003cList\u003cInteger\u003e\u003e res; public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { res = new ArrayList\u003c\u003e(); backtracking(candidates, 0, new LinkedList\u003c\u003e(), 0, target); return res; } public void backtracking(int[] candidates, int index, LinkedList\u003cInteger\u003e cur, int sum, int target) { if (sum \u003e target) { return; } if (sum == target) { // 这里注意，不能直接add，直接add永远都是这一个List，要复制一个新的List加进去 res.add(new ArrayList(cur)); return; } for (int i = index; i \u003c candidates.length; i++) { cur.add(candidates[i]); backtracking(candidates, i, cur, sum + candidates[i], target); cur.removeLast(); } } } 时间复杂度：$ O(S) $，其中 $S$ 为所有可行解的长度之和。我们可以分析出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 $O(n \\times 2^n) $是一个比较松的上界，即在这份代码中，$n$ 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 sum \u003e target 进行剪枝，所以实际运行情况是远远小于这个上界的 空间复杂度：$O(target)$。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 $O(\\textit{target}) $层 ","date":"2021-12-25","objectID":"/leetcode-0039.-combination-sum/:0:0","tags":["LeetCode","算法"],"title":"LeetCode 0039. Combination Sum","uri":"/leetcode-0039.-combination-sum/"},{"categories":["LeetCode题解"],"content":"A binary tree is named Even-Odd if it meets the following conditions: The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc. For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right). For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right). Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false. Example 1: Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2] Output: true Explanation: The node values on each level are: Level 0: [1] Level 1: [10,4] Level 2: [3,7,9] Level 3: [12,8,6,2] Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd. Example 2: Input: root = [5,4,2,3,3,7] Output: false Explanation: The node values on each level are: Level 0: [5] Level 1: [4,2] Level 2: [3,3,7] Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd. Example 3: Input: root = [5,9,1,3,5,7] Output: false Explanation: Node values in the level 1 should be even integers. Constraints: The number of nodes in the tree is in the range [1, 10^5]. 1 \u003c= Node.val \u003c= 10^6 思路 层序遍历的变种，多了几个判断条件： 根据层数的奇偶，判断每个节点值的奇偶 根据层数的奇偶，判断单调性，每次遍历一层开始时，设一个Integer pre = null 解法 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isEvenOddTree(TreeNode root) { boolean isEven = true; // 层数的奇偶 Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); q.offer(root); while (!q.isEmpty()) { int size = q.size(); Integer pre = null; for (int i = 0; i \u003c size; i++) { TreeNode cur = q.poll(); if (isEven) { // 偶数层 if (cur.val % 2 == 0) return false; if (pre != null \u0026\u0026 pre \u003e= cur.val) return false; } else { // 奇数层 if (cur.val % 2 == 1) return false; if (pre != null \u0026\u0026 pre \u003c= cur.val) return false; } pre = cur.val; if (cur.left != null) q.offer(cur.left); if (cur.right != null) q.offer(cur.right); } isEven = !isEven; } return true; } } 时间复杂度：$ O(N)$，$N$为树的节点和 空间复杂度：$O(N)$。 ","date":"2021-12-25","objectID":"/leetcode-1609.-even-odd-tree/:0:0","tags":["LeetCode","算法"],"title":"LeetCode 1609. Even Odd Tree","uri":"/leetcode-1609.-even-odd-tree/"},{"categories":["杂谈"],"content":"虽然还没太明白 但是还是成功post了第一篇博客 希望多年后回来看到这篇博客时，能感到自己没有虚度光阴 ","date":"2021-12-23","objectID":"/first_post/:0:0","tags":["杂谈"],"title":"First Post","uri":"/first_post/"}]