[{"categories":["LeetCodeé¢˜è§£"],"content":"æ³¨æ„ ğŸ‘» æœ¬äººæ°´å¹³æœ‰é™ï¼Œå¦‚æœ‰å»ºè®®ï¼Œæ¬¢è¿ç•™è¨€æˆ–é‚®ä»¶è”ç³» ğŸ‘» Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have *exactly* one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3: Input: nums = [3,3], target = 6 Output: [0,1] Constraints: 2 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity? æ€è·¯ ç»å…¸ two sum è§£æ³• class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); int[] res = new int[2]; for (int i = 0; i \u003c nums.length; i ++) { int complement = target - nums[i]; if (map.containsKey(complement)) { res[0] = i; res[1] = map.get(complement); break; } map.put(nums[i], i); } return res; } } ","date":"2021-12-25","objectID":"/leetcode_0001_twosum/:0:0","tags":["LeetCode","ç®—æ³•"],"title":"LeetCode 0001. TwoSum","uri":"/leetcode_0001_twosum/"},{"categories":["LeetCodeé¢˜è§£"],"content":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] Example 3: Input: candidates = [2], target = 1 Output: [] Constraints: 1 \u003c= candidates.length \u003c= 30 1 \u003c= candidates[i] \u003c= 200 All elements of candidates are distinct. 1 \u003c= target \u003c= 500 æ€è·¯ å…¸å‹çš„å›æº¯æ³•æ¨¡ç‰ˆé¢˜ï¼Œ ç”¨ä¸€ä¸ª list è®°å½•å½“å‰çš„ç»„åˆï¼Œç”¨ä¸€ä¸ª int sum è®°å½•ç»„åˆä¸­æ•°å­—ä¹‹å’Œï¼Œindexæ ‡è®°å·²ç»éå†åˆ°å“ªé‡Œï¼Œä¸‹ä¸€æ­¥å¯ä»¥é€‰æ‹©ä»indexåˆ°æœ€åä¸€ä¸ªæ•°ä¸­çš„ä»»ä½•ä¸€ä¸ª è§£æ³• class Solution { List\u003cList\u003cInteger\u003e\u003e res; public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { res = new ArrayList\u003c\u003e(); backtracking(candidates, 0, new LinkedList\u003c\u003e(), 0, target); return res; } public void backtracking(int[] candidates, int index, LinkedList\u003cInteger\u003e cur, int sum, int target) { if (sum \u003e target) { return; } if (sum == target) { // è¿™é‡Œæ³¨æ„ï¼Œä¸èƒ½ç›´æ¥addï¼Œç›´æ¥addæ°¸è¿œéƒ½æ˜¯è¿™ä¸€ä¸ªListï¼Œè¦å¤åˆ¶ä¸€ä¸ªæ–°çš„ListåŠ è¿›å» res.add(new ArrayList(cur)); return; } for (int i = index; i \u003c candidates.length; i++) { cur.add(candidates[i]); backtracking(candidates, i, cur, sum + candidates[i], target); cur.removeLast(); } } } æ—¶é—´å¤æ‚åº¦ï¼š$ O(S) $ï¼Œå…¶ä¸­ $S$ ä¸ºæ‰€æœ‰å¯è¡Œè§£çš„é•¿åº¦ä¹‹å’Œã€‚æˆ‘ä»¬å¯ä»¥åˆ†æå‡ºæ—¶é—´å¤æ‚åº¦å–å†³äºæœç´¢æ ‘æ‰€æœ‰å¶å­èŠ‚ç‚¹çš„æ·±åº¦ä¹‹å’Œï¼Œå³æ‰€æœ‰å¯è¡Œè§£çš„é•¿åº¦ä¹‹å’Œã€‚åœ¨è¿™é¢˜ä¸­ï¼Œæˆ‘ä»¬å¾ˆéš¾ç»™å‡ºä¸€ä¸ªæ¯”è¾ƒç´§çš„ä¸Šç•Œï¼Œæˆ‘ä»¬çŸ¥é“ $O(n \\times 2^n) $æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ¾çš„ä¸Šç•Œï¼Œå³åœ¨è¿™ä»½ä»£ç ä¸­ï¼Œ$n$ ä¸ªä½ç½®æ¯æ¬¡è€ƒè™‘é€‰æˆ–è€…ä¸é€‰ï¼Œå¦‚æœç¬¦åˆæ¡ä»¶ï¼Œå°±åŠ å…¥ç­”æ¡ˆçš„æ—¶é—´ä»£ä»·ã€‚ä½†æ˜¯å®é™…è¿è¡Œçš„æ—¶å€™ï¼Œå› ä¸ºä¸å¯èƒ½æ‰€æœ‰çš„è§£éƒ½æ»¡è¶³æ¡ä»¶ï¼Œé€’å½’çš„æ—¶å€™æˆ‘ä»¬è¿˜ä¼šç”¨ sum \u003e target è¿›è¡Œå‰ªæï¼Œæ‰€ä»¥å®é™…è¿è¡Œæƒ…å†µæ˜¯è¿œè¿œå°äºè¿™ä¸ªä¸Šç•Œçš„ ç©ºé—´å¤æ‚åº¦ï¼š$O(target)$ã€‚é™¤ç­”æ¡ˆæ•°ç»„å¤–ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºé€’å½’çš„æ ˆæ·±åº¦ï¼Œåœ¨æœ€å·®æƒ…å†µä¸‹éœ€è¦é€’å½’ $O(\\textit{target}) $å±‚ ","date":"2021-12-25","objectID":"/leetcode-0039.-combination-sum/:0:0","tags":["LeetCode","ç®—æ³•"],"title":"LeetCode 0039. Combination Sum","uri":"/leetcode-0039.-combination-sum/"},{"categories":["LeetCodeé¢˜è§£"],"content":"A binary tree is named Even-Odd if it meets the following conditions: The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc. For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right). For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right). Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false. Example 1: Input: root = [1,10,4,3,null,7,9,12,8,6,null,null,2] Output: true Explanation: The node values on each level are: Level 0: [1] Level 1: [10,4] Level 2: [3,7,9] Level 3: [12,8,6,2] Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing, the tree is Even-Odd. Example 2: Input: root = [5,4,2,3,3,7] Output: false Explanation: The node values on each level are: Level 0: [5] Level 1: [4,2] Level 2: [3,3,7] Node values in level 2 must be in strictly increasing order, so the tree is not Even-Odd. Example 3: Input: root = [5,9,1,3,5,7] Output: false Explanation: Node values in the level 1 should be even integers. Constraints: The number of nodes in the tree is in the range [1, 10^5]. 1 \u003c= Node.val \u003c= 10^6 æ€è·¯ å±‚åºéå†çš„å˜ç§ï¼Œå¤šäº†å‡ ä¸ªåˆ¤æ–­æ¡ä»¶ï¼š æ ¹æ®å±‚æ•°çš„å¥‡å¶ï¼Œåˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹å€¼çš„å¥‡å¶ æ ¹æ®å±‚æ•°çš„å¥‡å¶ï¼Œåˆ¤æ–­å•è°ƒæ€§ï¼Œæ¯æ¬¡éå†ä¸€å±‚å¼€å§‹æ—¶ï¼Œè®¾ä¸€ä¸ªInteger pre = null è§£æ³• /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isEvenOddTree(TreeNode root) { boolean isEven = true; // å±‚æ•°çš„å¥‡å¶ Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); q.offer(root); while (!q.isEmpty()) { int size = q.size(); Integer pre = null; for (int i = 0; i \u003c size; i++) { TreeNode cur = q.poll(); if (isEven) { // å¶æ•°å±‚ if (cur.val % 2 == 0) return false; if (pre != null \u0026\u0026 pre \u003e= cur.val) return false; } else { // å¥‡æ•°å±‚ if (cur.val % 2 == 1) return false; if (pre != null \u0026\u0026 pre \u003c= cur.val) return false; } pre = cur.val; if (cur.left != null) q.offer(cur.left); if (cur.right != null) q.offer(cur.right); } isEven = !isEven; } return true; } } æ—¶é—´å¤æ‚åº¦ï¼š$ O(N)$ï¼Œ$N$ä¸ºæ ‘çš„èŠ‚ç‚¹å’Œ ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ã€‚ ","date":"2021-12-25","objectID":"/leetcode-1609.-even-odd-tree/:0:0","tags":["LeetCode","ç®—æ³•"],"title":"LeetCode 1609. Even Odd Tree","uri":"/leetcode-1609.-even-odd-tree/"},{"categories":["æ‚è°ˆ"],"content":"è™½ç„¶è¿˜æ²¡å¤ªæ˜ç™½ ä½†æ˜¯è¿˜æ˜¯æˆåŠŸpostäº†ç¬¬ä¸€ç¯‡åšå®¢ å¸Œæœ›å¤šå¹´åå›æ¥çœ‹åˆ°è¿™ç¯‡åšå®¢æ—¶ï¼Œèƒ½æ„Ÿåˆ°è‡ªå·±æ²¡æœ‰è™šåº¦å…‰é˜´ ","date":"2021-12-23","objectID":"/first_post/:0:0","tags":["æ‚è°ˆ"],"title":"First Post","uri":"/first_post/"}]